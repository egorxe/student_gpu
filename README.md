# Student GPU

## Структура каталогов

* **doc** - полезная документация;
* **src** - исходные коды;
    * **emu** - эмулятор конвейера GPU, из этой папки производится его запуск;
        * **stages**
            * **с++** - в подпапках лежат C++ реализации стадий GPU;
            * **rtl** - ссылка на папку src/rtl, эти пути эквивалентны;
    * **rtl** - исходные коды RTL;
        * **pkg** - глобальные VHDL пакеты проекта;
    * **tests** - программные тесты;


## Инструкции

### Запуск эмулятора конвейера GPU

Эмулятор запускается из папки src/emu командой:
```
./gpu_emu.py config.json
```
, где config.json - имя конфигурационного файла эмулятора, если его не указывать, то будет использован конфиг-файл gpu_config.json. 

Для перекомпиляции кода C++ стадий эмулятора после их изменения необходимо либо выполнить команду make в папке изменённой стадии, либо для проверки всех стадий и пересборки изменившихся выполнить make в папке src/emu. Можно запускать make перед каждым стартом эмулятора, например так:
```
make && ./gpu_emu.py gpu_config.json
```


### Добавление RTL реализации стадии конвейера GPU

Для добавления своей VHDL реализации стадии конвейера необходимо создать для неё подпапку в src/rtl, положить туда исходные файлы, после чего добавить скрипт для запуска симулятора. В качестве скрипта запуска рекомендуется использовать скрипт ghdl_sim/stage_sim.sh из папки примера src/rtl/test_vertices. Для его использования необходимо по аналогии создать в папке своей стадии подпапку ghdl_sim и скопировать в неё скрипт stage_sim.sh. В скрипте необходимо откорректировать значения переменных:
- *TOP* - имя entity верхнего уровня;
- *SOURCES_BASEPATH* - базовый путь до исходников относительно расположения скрипта, если все файлы лежат в папке стадии, то можно просто оставить "..";
- *SOURCES* - список исходников через пробел (с путями относительно базового), если нужно компилировать все vhd-файлы в базовой папке, то можно оставить "*.vhd";
- *PACKAGES* - файлы пакетов из папки src/rtl/pkg, обычно менять не требуется.

Теперь для использования RTL-стадии в конвейере эмулятора необходимо создать JSON-конфиг. Базовый конфиг использующий на всех стадиях референсные C++ реализации находится в gpu_config.json. В качестве примера с RTL-стадией можно использовать rtltestvertices.json, где первая стадия генерирующая тестовые вершины заменена на src/rtl/test_vertices (см. значение "binary"). Для оптимальной производительности и во избежании наложения ошибок в каждом отдельном конфиге рекомендуется заменять на RTL только одну стадию. 


Следует иметь ввиду, что путь src/emu/stages/rtl является символической ссылкой на путь src/rtl, поэтому в src/emu/stages/rtl ничего менять не нужно. На Windows символическая ссылка будет отображаться как текстовый файл.


## VHDL пакеты (package)

Глобальные VHDL пакеты, которые могут пригодиться во всех RTL-модулях располагаются в папке src/rtl/pkg. На настоящий момент таких пакета 2: **gpu_pkg** и **file_helper_pkg**.

### gpu_pkg

Пакет содержащий глобальные типы, константы и полезные функции. Рекомендуется включать его во все файлы проекта.

### Типы

| Тип           | Описание
|---------------|-------------------------------------------|
| vec32         | std_logic_vector(31 downto 0)             |


### Константы

| Константа     | Описание
|---------------|-------------------------------------------|
| ZF            | Нулевой float32                           |
| ZERO32        | Нулевой std_logic_vector(31 downto 0)     |
| GPU_PIPE_CMD_*| Коды команд передаваемых по конвейеру     |


### Функции и процедуры

| Функция                               | Описание
|---------------------------------------|-----------------------------------------------------------|
| tf(x : real)                          | Приводит x типа real к типу float32                       |
| to_slv(a : integer; size : natural)   | Приводит целое a к типу std_logic_vector(size-1 downto 0) |
| to_vec32(a : integer)                 | Приводит целое a к типу std_logic_vector(31 downto 0)     |
| zero_vec(size : integer)              | Возвращает нулевой std_logic_vector длиной size           |


### file_helper_pkg

Пакет содержащий типы и функции упрощающие работу с бинарными файлами. Помогает читать и писать FIFO конвейера.

### Типы

| Тип           | Описание
|---------------|-------------------------------------------|
| BinaryFile    | Бинарный файловый тип                     |


### Константы

| Константа     | Описание
|---------------|-------------------------------------------|
| ZF            | Нулевой float32                           |
| ZERO32        | Нулевой std_logic_vector(31 downto 0)     |
| GPU_PIPE_CMD_*| Коды команд передаваемых по конвейеру     |


### Функции и процедуры

| Функция                                   | Описание
|-------------------------------------------|-----------------------------------------------|
| WriteUint32(f : BinaryFile; v : vec32)    | Запись 32-битного вектора в бинарный файл     |
| ReadUint32(f : BinaryFile; v : vec32)     | Чтение 32-битного вектора из бинарного файла  |
| WriteFloat(f : BinaryFile; v : float32)   | Запись float32 в бинарный файл                |
| ReadFloat(f : BinaryFile; v : float32)    | Чтение float32 из бинарного файла             |



## Стадии конвейера

Порядок стадий соответствует порядку в конвейере, названия приводятся по src/emu/stages/c++.

### Генерация исходных вершин (*test_vertices*)

Стадия генеруруей тестовые вершины и команды для обработки конвейером.

Ответственный - **Егор**.


### Преобразования вершин (*vertex_transform*)

На этой стадии производятся преобразования координат вершин. Координаты вершин последовательно умножаются на две матрицы (матрицу модели и матрицу проекции), после чего производится преобразование к экранным координатам (vieport transform).

Ответственный - **Дима**.


### Растеризация (*rasterizer*)

На этой стадии производится перевод координат вершин полигонов в набор координат фактически отображаемых пикселей и их цветов (фрагменты).

Ответственные - **Надя** (edge-function и цвета) и **Никита** (z-координата).


### Преобразования фрагментов (*fragment_ops*)

На этой стадии производятся операции над фрагментами. На настоящий момент мы поддерживаем только одну операцию - фильтрацию по глубине (z-буфер).

Ответственный - **Никита**.

